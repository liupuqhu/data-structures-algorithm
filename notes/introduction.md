# 引论

## 核心内容
* 写出一个工作程序并不够，运行时间还要足够短。

## 数学基础
* 指数
* 对数
* 级数        欧拉常数
* 模运算 
* 证明的思路   数学归纳法、反证法

## 递归简论
递归例程的四条基本法则：
* 基准情形
* 不断推进
* 设计法则
* 合成效益法则

## java语法

### pre-java5实现泛型构建

#### 实现思路
* C++使用模板实现泛型
* pre-java5使用继承实现泛型
* java5支持泛型

#### 实现方式
* 使用Object实现泛型
* 8中基本类型与Object不相容，所以引入基本类型的包装
* 使用接口类型表示泛型  Comparable接口
* 数组类型的兼容性  
##### java中数组是类型兼容的，成为协变数组类型。如果将一个不兼容的类型插入到数组中，那么虚拟机将抛出一个ArrayStoreException异常。

### java5泛型特性实现

* 简单泛型类和接口
###### 通过使类编程泛型类，以前只有在运行时才能报告的许多错误如今变成了编译时的错误。

* 自动装箱/拆箱
###### pre-java5不支持包装类和基本类型的默认转换，经常报错，java5矫正了这种情况。

* 菱形运算符
###### java7引入的语法新特性，在不增加开发者负担的情况下简化了代码。

* 带有限制的通配符
###### 因为使用泛型的全部原因就在于产生编译器错误而不是类型不匹配的运行时异常，所以，泛型集合不是协变的。泛型及泛型集合不是协变的，但是数组是协变的，会导致用户避免使用集合。java5用通配符类(wildcard)弥补这个不足。

* 泛型static方法

public static <AnyType> boolean contains(AnyType[] arr, AnyType x) ...

* 类型限界
###### 类型限界在尖括号内指定，它指定参数类型必须具有的性质。
public static <AnyType extends Comparable> ...

public static <AnyType extends Comparable<AnyType>> ...

###### 由于我们不需要知道准确的类型T，因此可以使用通配符。
public static <AnyType extends Comparable<? extends AnyType>> ...

* 类型擦除
###### 泛型在很大程度上是java语言中的成分而不是虚拟机中的结构。泛型类可以由编译器通过所谓的类型擦除(type erasure)过程转变成非泛型类。

* 对于泛型的限制
1. 基本类型不能用做类型参数
2. instanceof 检测和类型转换工作只对原始类型进行
3. 在一个泛型类中，static方法和static域均不可引用类的类型变量，因为在类型擦除后类型变量就不存在了。
4. 不能创建一个泛型类型的实例
5. 也不能创建一个泛型的数组

* 函数对象 Comparator<AnyType>


## 总结
* 本章主要介绍了为什么要学习DSA，因为性能很重要。
* 一些离散数学的基础知识和常用思想(归纳和反证),以及计算机科学中常用的递归方法。
* 针对java的语言特性，主要介绍了java5前后对于泛型的支持，以及泛型使用中的一些注意点。





















